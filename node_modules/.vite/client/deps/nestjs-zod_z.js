import {
  BRAND,
  DIRTY,
  EMPTY_PATH,
  INVALID,
  NEVER,
  OK,
  ParseStatus,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  ZodFirstPartyTypeKind,
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  addIssueToContext,
  anyType,
  arrayType,
  bigIntType,
  booleanType,
  coerce,
  custom,
  dateType,
  datetimeRegex,
  discriminatedUnionType,
  effectsType,
  enumType,
  errorMap,
  functionType,
  getErrorMap,
  getParsedType,
  instanceOfType,
  intersectionType,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  late,
  lazyType,
  lib_exports,
  literalType,
  makeIssue,
  mapType,
  nanType,
  nativeEnumType,
  neverType,
  nullType,
  nullableType,
  numberType,
  objectType,
  objectUtil,
  oboolean,
  onumber,
  optionalType,
  ostring,
  pipelineType,
  preprocessType,
  promiseType,
  quotelessJson,
  recordType,
  setErrorMap,
  setType,
  strictObjectType,
  stringType,
  symbolType,
  tupleType,
  undefinedType,
  unionType,
  unknownType,
  util,
  voidType,
  z
} from "./chunk-KXONEZZH.js";
import "./chunk-SNAQBZPT.js";

// node_modules/.pnpm/nestjs-zod@3.0.0_@nestjs+common@10.4.1_reflect-metadata@0.2.2_rxjs@7.8.1__@nestjs+core@10.4.1_mosqiba7rlbtyjrsai3mpd2uky/node_modules/nestjs-zod/dist/z.mjs
function _mergeNamespaces(n, m) {
  m.forEach(function(e) {
    e && typeof e !== "string" && !Array.isArray(e) && Object.keys(e).forEach(function(k) {
      if (k !== "default" && !(k in n)) {
        var d = Object.getOwnPropertyDescriptor(e, k);
        Object.defineProperty(n, k, d.get ? d : {
          enumerable: true,
          get: function() {
            return e[k];
          }
        });
      }
    });
  });
  return Object.freeze(n);
}
var CUSTOM_ISSUE_CODE = "custom";
function isNestJsZodIssue(issue) {
  var _a;
  return issue.code === CUSTOM_ISSUE_CODE && ((_a = issue.params) == null ? void 0 : _a.isNestJsZod);
}
function composeMappers(mappers) {
  return (issue) => {
    for (const mapper2 of mappers) {
      const result = mapper2(issue);
      if (!result.matched)
        continue;
      return result;
    }
    return { matched: false };
  };
}
function createCustomMapper(map) {
  return (issue) => {
    if (!isNestJsZodIssue(issue))
      return { matched: false };
    const result = map(issue.params);
    if (!result.matched)
      return { matched: false };
    return result;
  };
}
function createMinMaxMapper(valueType, map) {
  return (issue) => {
    if (issue.code !== ZodIssueCode.too_small && issue.code !== ZodIssueCode.too_big) {
      return { matched: false };
    }
    if (issue.type !== valueType) {
      return { matched: false };
    }
    const result = map(issue);
    if (!result.matched)
      return { matched: false };
    return result;
  };
}
var dateStringCustom = createCustomMapper((params) => {
  if (params.code === "invalid_date_string") {
    const message = `Invalid string, expected it to be a valid date`;
    return { matched: true, message };
  }
  if (params.code === "invalid_date_string_format") {
    const mapper2 = {
      "date": 'YYYY-MM-DD (RFC3339 "full-date")',
      "date-time": 'YYYY-MM-DDTHH:mm:ssZ (RFC3339 "date-time")'
    };
    const readable = mapper2[params.expected];
    const message = `Invalid date, expected it to match ${readable}`;
    return { matched: true, message };
  }
  if (params.code === "invalid_date_string_direction") {
    const message = `Invalid date, expected it to be the ${params.expected}`;
    return { matched: true, message };
  }
  if (params.code === "invalid_date_string_day") {
    const mapper2 = {
      weekDay: "week day",
      weekend: "weekend"
    };
    const readable = mapper2[params.expected];
    const message = `Invalid date, expected it to be a ${readable}`;
    return { matched: true, message };
  }
  return { matched: false };
});
var dateStringYearMinMax = createMinMaxMapper("date_string_year", (issue) => {
  if (issue.code === ZodIssueCode.too_small) {
    const appendix = issue.inclusive ? "or equal to " : "";
    const message = `Year must be greater than ${appendix}${issue.minimum}`;
    return { matched: true, message };
  }
  if (issue.code === ZodIssueCode.too_big) {
    const appendix = issue.inclusive ? "or equal to " : "";
    const message = `Year must be less than ${appendix}${issue.maximum}`;
    return { matched: true, message };
  }
  return { matched: false };
});
var passwordCustom = createCustomMapper((params) => {
  if (params.code === "invalid_password_no_digit") {
    const message = `Password must contain at least one digit`;
    return { matched: true, message };
  }
  if (params.code === "invalid_password_no_lowercase") {
    const message = `Password must contain at least one lowercase letter`;
    return { matched: true, message };
  }
  if (params.code === "invalid_password_no_uppercase") {
    const message = `Password must contain at least one uppercase letter`;
    return { matched: true, message };
  }
  if (params.code === "invalid_password_no_special") {
    const message = `Password must contain at least one special symbol`;
    return { matched: true, message };
  }
  return { matched: false };
});
var passwordMinMax = createMinMaxMapper("password", (issue) => {
  if (issue.code === ZodIssueCode.too_small) {
    const appendix = issue.inclusive ? "or equal to " : "";
    const message = `Password length must be greater than ${appendix}${issue.minimum}`;
    return { matched: true, message };
  }
  if (issue.code === ZodIssueCode.too_big) {
    const appendix = issue.inclusive ? "or equal to " : "";
    const message = `Password length must be less than ${appendix}${issue.maximum}`;
    return { matched: true, message };
  }
  return { matched: false };
});
var mapper = composeMappers([
  dateStringCustom,
  dateStringYearMinMax,
  passwordCustom,
  passwordMinMax
]);
var extendedErrorMap = (issue, context) => {
  const result = mapper(issue);
  if (result.matched) {
    return { message: result.message };
  }
  return errorMap(issue, context);
};
function setExtendedErrorMap(map) {
  setErrorMap(map);
}
setExtendedErrorMap(extendedErrorMap);
function from(schema) {
  return schema;
}
var literal = z.union([z.string(), z.number(), z.boolean()]);
var DEFAULT_MESSAGE = "Expected value to be a JSON-serializable";
var json = (message = DEFAULT_MESSAGE) => {
  const schema = z.lazy(() => z.union([literal, z.array(schema), z.record(schema)], {
    invalid_type_error: message
  }));
  return schema;
};
function addIssueToContextExtended(context, issueData) {
  addIssueToContext(context, issueData);
}
function normalizeErrorMessage(message) {
  if (typeof message === "string")
    return { message };
  return message;
}
function processCreateParams(params) {
  if (!params)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid" or "required" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = (issue, context) => {
    if (issue.code !== "invalid_type")
      return { message: context.defaultError };
    if (typeof context.data === "undefined" && required_error)
      return { message: required_error };
    if (params.invalid_type_error)
      return { message: params.invalid_type_error };
    return { message: context.defaultError };
  };
  return { errorMap: customMap, description };
}
function findCheck(checks, kind) {
  return checks.find((check) => check.kind === kind);
}
function hasCheck(checks, kind) {
  return Boolean(findCheck(checks, kind));
}
var ZodFirstPartyTypeKindExtended = ((ZodFirstPartyTypeKindExtended2) => {
  ZodFirstPartyTypeKindExtended2["ZodDateString"] = "ZodDateString";
  ZodFirstPartyTypeKindExtended2["ZodPassword"] = "ZodPassword";
  return ZodFirstPartyTypeKindExtended2;
})(ZodFirstPartyTypeKindExtended || {});
var __defProp$1 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
var formatToRegex = {
  "date": /^\d{4}-\d{2}-\d{2}$/,
  "date-time": /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(|\.\d{3})(Z|[+-]\d{2}:\d{2})$/
};
var _ZodDateString = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    const context = this._getOrReturnCtx(input);
    if (parsedType !== ZodParsedType.string) {
      addIssueToContextExtended(context, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: context.parsedType
      });
      return INVALID;
    }
    const date = new Date(input.data);
    if (Number.isNaN(date.getTime())) {
      addIssueToContextExtended(context, {
        code: ZodIssueCode.custom,
        message: "Invalid date string",
        params: {
          isNestJsZod: true,
          code: "invalid_date_string"
        }
      });
      return INVALID;
    }
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (check.kind === "format") {
        const valid = check.regex.test(input.data);
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.custom,
          message: check.message,
          params: {
            isNestJsZod: true,
            code: "invalid_date_string_format",
            expected: check.value
          }
        });
        status.dirty();
      } else if (check.kind === "direction") {
        const conditions = {
          past: date < /* @__PURE__ */ new Date(),
          future: date > /* @__PURE__ */ new Date()
        };
        const valid = conditions[check.direction];
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.custom,
          message: check.message,
          params: {
            isNestJsZod: true,
            code: "invalid_date_string_direction",
            expected: check.direction
          }
        });
        status.dirty();
      } else if (check.kind === "day-type") {
        const day = date.getDay();
        const conditions = {
          weekDay: day !== 0 && day !== 6,
          weekend: day === 0 || day === 6
        };
        const valid = conditions[check.type];
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.custom,
          message: check.message,
          params: {
            isNestJsZod: true,
            code: "invalid_date_string_day",
            expected: check.type
          }
        });
        status.dirty();
      } else if (check.kind === "minYear") {
        const valid = date.getFullYear() >= check.value;
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.too_small,
          type: "date_string_year",
          minimum: check.value,
          inclusive: true,
          message: check.message
        });
        status.dirty();
      } else if (check.kind === "maxYear") {
        const valid = date.getFullYear() <= check.value;
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.too_big,
          type: "date_string_year",
          maximum: check.value,
          inclusive: true,
          message: check.message
        });
        status.dirty();
      }
    }
    return { status: status.value, value: input.data };
  }
  _replaceCheck(check) {
    return new _ZodDateString(__spreadProps$1(__spreadValues$1({}, this._def), {
      checks: this._def.checks.filter((item) => item.kind !== check.kind).concat(check)
    }));
  }
  format(format, message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "format",
      value: format,
      regex: formatToRegex[format]
    }, normalizeErrorMessage(message)));
  }
  past(message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "direction",
      direction: "past"
    }, normalizeErrorMessage(message)));
  }
  future(message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "direction",
      direction: "future"
    }, normalizeErrorMessage(message)));
  }
  weekDay(message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "day-type",
      type: "weekDay"
    }, normalizeErrorMessage(message)));
  }
  weekend(message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "day-type",
      type: "weekend"
    }, normalizeErrorMessage(message)));
  }
  minYear(year, message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "minYear",
      value: year
    }, normalizeErrorMessage(message)));
  }
  maxYear(year, message) {
    return this._replaceCheck(__spreadValues$1({
      kind: "maxYear",
      value: year
    }, normalizeErrorMessage(message)));
  }
  cast() {
    return this.transform((string) => new Date(string));
  }
  get format_() {
    return findCheck(this._def.checks, "format");
  }
  get isPast() {
    var _a;
    return ((_a = findCheck(this._def.checks, "direction")) == null ? void 0 : _a.direction) === "past";
  }
  get isFuture() {
    var _a;
    return ((_a = findCheck(this._def.checks, "direction")) == null ? void 0 : _a.direction) === "future";
  }
  get isWeekDay() {
    var _a;
    return ((_a = findCheck(this._def.checks, "day-type")) == null ? void 0 : _a.type) === "weekDay";
  }
  get isWeekend() {
    var _a;
    return ((_a = findCheck(this._def.checks, "day-type")) == null ? void 0 : _a.type) === "weekend";
  }
  get minYear_() {
    return findCheck(this._def.checks, "minYear");
  }
  get maxYear_() {
    return findCheck(this._def.checks, "maxYear");
  }
};
var ZodDateString = _ZodDateString;
ZodDateString.create = (params) => {
  return new _ZodDateString(__spreadValues$1({
    checks: [
      {
        kind: "format",
        value: "date-time",
        regex: formatToRegex["date-time"]
      }
    ],
    typeName: ZodFirstPartyTypeKindExtended.ZodDateString
  }, processCreateParams(params)));
};
var dateString = ZodDateString.create;
var __defProp = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
var SYMBOL_KINDS = [
  "digit",
  "lowercase",
  "uppercase",
  "special"
];
var REGEXPS = {
  digit: /\d/,
  lowercase: /[a-z]/,
  uppercase: /[A-Z]/,
  special: /[!?@#$%^&*{};.,:%â„–"|\\/()\-_+=<>`~[\]'"]/
};
function isSymbolCheck(check) {
  return SYMBOL_KINDS.includes(check.kind);
}
var _ZodPassword = class extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    const context = this._getOrReturnCtx(input);
    if (parsedType !== ZodParsedType.string) {
      addIssueToContextExtended(context, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: context.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus();
    for (const check of this._def.checks) {
      if (isSymbolCheck(check)) {
        const valid = REGEXPS[check.kind].test(input.data);
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.custom,
          message: check.message,
          params: {
            isNestJsZod: true,
            code: `invalid_password_no_${check.kind}`
          }
        });
        status.dirty();
      } else if (check.kind === "minLength") {
        const valid = input.data.length >= check.value;
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.too_small,
          type: "password",
          minimum: check.value,
          inclusive: true,
          message: check.message
        });
        status.dirty();
      } else if (check.kind === "maxLength") {
        const valid = input.data.length <= check.value;
        if (valid)
          continue;
        addIssueToContextExtended(context, {
          code: ZodIssueCode.too_big,
          type: "password",
          maximum: check.value,
          inclusive: true,
          message: check.message
        });
        status.dirty();
      }
    }
    return { status: status.value, value: input.data };
  }
  _replaceCheck(check) {
    return new _ZodPassword(__spreadProps(__spreadValues({}, this._def), {
      checks: this._def.checks.filter((item) => item.kind !== check.kind).concat(check)
    }));
  }
  buildFullRegExp() {
    const lookaheads = [];
    for (const check of this._def.checks) {
      if (!isSymbolCheck(check))
        continue;
      const regex = REGEXPS[check.kind];
      lookaheads.push(`(?=.*${regex.source})`);
    }
    if (lookaheads.length === 0) {
      return /^.*$/;
    }
    const union = lookaheads.join("");
    return new RegExp(`^(?:${union}.*)$`);
  }
  atLeastOne(kind, message) {
    return this._replaceCheck(__spreadValues({
      kind
    }, normalizeErrorMessage(message)));
  }
  min(length, message) {
    return this._replaceCheck(__spreadValues({
      kind: "minLength",
      value: length
    }, normalizeErrorMessage(message)));
  }
  max(length, message) {
    return this._replaceCheck(__spreadValues({
      kind: "maxLength",
      value: length
    }, normalizeErrorMessage(message)));
  }
  isAtLeastOne(kind) {
    return hasCheck(this._def.checks, kind);
  }
  get minLength() {
    return findCheck(this._def.checks, "minLength");
  }
  get maxLength() {
    return findCheck(this._def.checks, "maxLength");
  }
};
var ZodPassword = _ZodPassword;
ZodPassword.create = (params) => {
  return new _ZodPassword(__spreadValues({
    checks: [],
    typeName: ZodFirstPartyTypeKindExtended.ZodPassword
  }, processCreateParams(params)));
};
var password = ZodPassword.create;
var onlyOverride = _mergeNamespaces({
  __proto__: null,
  defaultErrorMap: extendedErrorMap,
  setErrorMap: setExtendedErrorMap,
  addIssueToContext: addIssueToContextExtended,
  from,
  json,
  ZodDateString,
  dateString,
  ZodPassword,
  password,
  ZodFirstPartyTypeKindExtended
}, [lib_exports]);
export {
  BRAND,
  DIRTY,
  EMPTY_PATH,
  INVALID,
  NEVER,
  OK,
  ParseStatus,
  ZodType as Schema,
  ZodAny,
  ZodArray,
  ZodBigInt,
  ZodBoolean,
  ZodBranded,
  ZodCatch,
  ZodDate,
  ZodDateString,
  ZodDefault,
  ZodDiscriminatedUnion,
  ZodEffects,
  ZodEnum,
  ZodError,
  ZodFirstPartyTypeKind,
  ZodFirstPartyTypeKindExtended,
  ZodFunction,
  ZodIntersection,
  ZodIssueCode,
  ZodLazy,
  ZodLiteral,
  ZodMap,
  ZodNaN,
  ZodNativeEnum,
  ZodNever,
  ZodNull,
  ZodNullable,
  ZodNumber,
  ZodObject,
  ZodOptional,
  ZodParsedType,
  ZodPassword,
  ZodPipeline,
  ZodPromise,
  ZodReadonly,
  ZodRecord,
  ZodType as ZodSchema,
  ZodSet,
  ZodString,
  ZodSymbol,
  ZodEffects as ZodTransformer,
  ZodTuple,
  ZodType,
  ZodUndefined,
  ZodUnion,
  ZodUnknown,
  ZodVoid,
  addIssueToContextExtended as addIssueToContext,
  anyType as any,
  arrayType as array,
  bigIntType as bigint,
  booleanType as boolean,
  coerce,
  custom,
  dateType as date,
  dateString,
  datetimeRegex,
  extendedErrorMap as defaultErrorMap,
  discriminatedUnionType as discriminatedUnion,
  effectsType as effect,
  enumType as enum,
  from,
  functionType as function,
  getErrorMap,
  getParsedType,
  instanceOfType as instanceof,
  intersectionType as intersection,
  isAborted,
  isAsync,
  isDirty,
  isValid,
  json,
  late,
  lazyType as lazy,
  literalType as literal,
  makeIssue,
  mapType as map,
  nanType as nan,
  nativeEnumType as nativeEnum,
  neverType as never,
  nullType as null,
  nullableType as nullable,
  numberType as number,
  objectType as object,
  objectUtil,
  oboolean,
  onumber,
  optionalType as optional,
  ostring,
  password,
  pipelineType as pipeline,
  preprocessType as preprocess,
  promiseType as promise,
  quotelessJson,
  recordType as record,
  setType as set,
  setExtendedErrorMap as setErrorMap,
  strictObjectType as strictObject,
  stringType as string,
  symbolType as symbol,
  effectsType as transformer,
  tupleType as tuple,
  undefinedType as undefined,
  unionType as union,
  unknownType as unknown,
  util,
  voidType as void,
  onlyOverride as z
};
//# sourceMappingURL=nestjs-zod_z.js.map
